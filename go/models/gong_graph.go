// generated by ModelGongGraphFileTemplate
package models

func IsStaged[Type Gongstruct](stage *StageStruct, instance *Type) (ok bool) {

	switch target := any(instance).(type) {
	// insertion point for stage
	case *Document:
		ok = stage.IsStagedDocument(target)

	case *Docx:
		ok = stage.IsStagedDocx(target)

	case *File:
		ok = stage.IsStagedFile(target)

	case *Node:
		ok = stage.IsStagedNode(target)

	case *Paragraph:
		ok = stage.IsStagedParagraph(target)

	case *ParagraphProperties:
		ok = stage.IsStagedParagraphProperties(target)

	case *ParagraphStyle:
		ok = stage.IsStagedParagraphStyle(target)

	case *Rune:
		ok = stage.IsStagedRune(target)

	case *RuneProperties:
		ok = stage.IsStagedRuneProperties(target)

	case *Table:
		ok = stage.IsStagedTable(target)

	case *TableProperties:
		ok = stage.IsStagedTableProperties(target)

	case *TableStyle:
		ok = stage.IsStagedTableStyle(target)

	case *Text:
		ok = stage.IsStagedText(target)

	default:
		_ = target
	}
	return
}

// insertion point for stage per struct
	func (stage *StageStruct) IsStagedDocument(document *Document) (ok bool) {

		_, ok = stage.Documents[document]
	
		return
	}

	func (stage *StageStruct) IsStagedDocx(docx *Docx) (ok bool) {

		_, ok = stage.Docxs[docx]
	
		return
	}

	func (stage *StageStruct) IsStagedFile(file *File) (ok bool) {

		_, ok = stage.Files[file]
	
		return
	}

	func (stage *StageStruct) IsStagedNode(node *Node) (ok bool) {

		_, ok = stage.Nodes[node]
	
		return
	}

	func (stage *StageStruct) IsStagedParagraph(paragraph *Paragraph) (ok bool) {

		_, ok = stage.Paragraphs[paragraph]
	
		return
	}

	func (stage *StageStruct) IsStagedParagraphProperties(paragraphproperties *ParagraphProperties) (ok bool) {

		_, ok = stage.ParagraphPropertiess[paragraphproperties]
	
		return
	}

	func (stage *StageStruct) IsStagedParagraphStyle(paragraphstyle *ParagraphStyle) (ok bool) {

		_, ok = stage.ParagraphStyles[paragraphstyle]
	
		return
	}

	func (stage *StageStruct) IsStagedRune(rune *Rune) (ok bool) {

		_, ok = stage.Runes[rune]
	
		return
	}

	func (stage *StageStruct) IsStagedRuneProperties(runeproperties *RuneProperties) (ok bool) {

		_, ok = stage.RunePropertiess[runeproperties]
	
		return
	}

	func (stage *StageStruct) IsStagedTable(table *Table) (ok bool) {

		_, ok = stage.Tables[table]
	
		return
	}

	func (stage *StageStruct) IsStagedTableProperties(tableproperties *TableProperties) (ok bool) {

		_, ok = stage.TablePropertiess[tableproperties]
	
		return
	}

	func (stage *StageStruct) IsStagedTableStyle(tablestyle *TableStyle) (ok bool) {

		_, ok = stage.TableStyles[tablestyle]
	
		return
	}

	func (stage *StageStruct) IsStagedText(text *Text) (ok bool) {

		_, ok = stage.Texts[text]
	
		return
	}


// StageBranch stages instance and apply StageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func StageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for stage branch
	case *Document:
		stage.StageBranchDocument(target)

	case *Docx:
		stage.StageBranchDocx(target)

	case *File:
		stage.StageBranchFile(target)

	case *Node:
		stage.StageBranchNode(target)

	case *Paragraph:
		stage.StageBranchParagraph(target)

	case *ParagraphProperties:
		stage.StageBranchParagraphProperties(target)

	case *ParagraphStyle:
		stage.StageBranchParagraphStyle(target)

	case *Rune:
		stage.StageBranchRune(target)

	case *RuneProperties:
		stage.StageBranchRuneProperties(target)

	case *Table:
		stage.StageBranchTable(target)

	case *TableProperties:
		stage.StageBranchTableProperties(target)

	case *TableStyle:
		stage.StageBranchTableStyle(target)

	case *Text:
		stage.StageBranchText(target)

	default:
		_ = target
	}
}

// insertion point for stage branch per struct
func (stage *StageStruct) StageBranchDocument(document *Document) {

	// check if instance is already staged
	if IsStaged(stage, document) {
		return
	}

	document.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if document.File != nil {
		StageBranch(stage, document.File)
	}
	if document.Root != nil {
		StageBranch(stage, document.Root)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchDocx(docx *Docx) {

	// check if instance is already staged
	if IsStaged(stage, docx) {
		return
	}

	docx.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _file := range docx.Files {
		StageBranch(stage, _file)
	}

}

func (stage *StageStruct) StageBranchFile(file *File) {

	// check if instance is already staged
	if IsStaged(stage, file) {
		return
	}

	file.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchNode(node *Node) {

	// check if instance is already staged
	if IsStaged(stage, node) {
		return
	}

	node.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _node := range node.Nodes {
		StageBranch(stage, _node)
	}

}

func (stage *StageStruct) StageBranchParagraph(paragraph *Paragraph) {

	// check if instance is already staged
	if IsStaged(stage, paragraph) {
		return
	}

	paragraph.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraph.Node != nil {
		StageBranch(stage, paragraph.Node)
	}
	if paragraph.ParagraphProperties != nil {
		StageBranch(stage, paragraph.ParagraphProperties)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _rune := range paragraph.Runes {
		StageBranch(stage, _rune)
	}

}

func (stage *StageStruct) StageBranchParagraphProperties(paragraphproperties *ParagraphProperties) {

	// check if instance is already staged
	if IsStaged(stage, paragraphproperties) {
		return
	}

	paragraphproperties.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraphproperties.ParagraphStyle != nil {
		StageBranch(stage, paragraphproperties.ParagraphStyle)
	}
	if paragraphproperties.Node != nil {
		StageBranch(stage, paragraphproperties.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchParagraphStyle(paragraphstyle *ParagraphStyle) {

	// check if instance is already staged
	if IsStaged(stage, paragraphstyle) {
		return
	}

	paragraphstyle.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraphstyle.Node != nil {
		StageBranch(stage, paragraphstyle.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchRune(rune *Rune) {

	// check if instance is already staged
	if IsStaged(stage, rune) {
		return
	}

	rune.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if rune.Node != nil {
		StageBranch(stage, rune.Node)
	}
	if rune.Text != nil {
		StageBranch(stage, rune.Text)
	}
	if rune.RuneProperties != nil {
		StageBranch(stage, rune.RuneProperties)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchRuneProperties(runeproperties *RuneProperties) {

	// check if instance is already staged
	if IsStaged(stage, runeproperties) {
		return
	}

	runeproperties.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if runeproperties.Node != nil {
		StageBranch(stage, runeproperties.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchTable(table *Table) {

	// check if instance is already staged
	if IsStaged(stage, table) {
		return
	}

	table.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if table.Node != nil {
		StageBranch(stage, table.Node)
	}
	if table.TableProperties != nil {
		StageBranch(stage, table.TableProperties)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchTableProperties(tableproperties *TableProperties) {

	// check if instance is already staged
	if IsStaged(stage, tableproperties) {
		return
	}

	tableproperties.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if tableproperties.Node != nil {
		StageBranch(stage, tableproperties.Node)
	}
	if tableproperties.TableStyle != nil {
		StageBranch(stage, tableproperties.TableStyle)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchTableStyle(tablestyle *TableStyle) {

	// check if instance is already staged
	if IsStaged(stage, tablestyle) {
		return
	}

	tablestyle.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if tablestyle.Node != nil {
		StageBranch(stage, tablestyle.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchText(text *Text) {

	// check if instance is already staged
	if IsStaged(stage, text) {
		return
	}

	text.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if text.Node != nil {
		StageBranch(stage, text.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}


// UnstageBranch stages instance and apply UnstageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func UnstageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for unstage branch
	case *Document:
		stage.UnstageBranchDocument(target)

	case *Docx:
		stage.UnstageBranchDocx(target)

	case *File:
		stage.UnstageBranchFile(target)

	case *Node:
		stage.UnstageBranchNode(target)

	case *Paragraph:
		stage.UnstageBranchParagraph(target)

	case *ParagraphProperties:
		stage.UnstageBranchParagraphProperties(target)

	case *ParagraphStyle:
		stage.UnstageBranchParagraphStyle(target)

	case *Rune:
		stage.UnstageBranchRune(target)

	case *RuneProperties:
		stage.UnstageBranchRuneProperties(target)

	case *Table:
		stage.UnstageBranchTable(target)

	case *TableProperties:
		stage.UnstageBranchTableProperties(target)

	case *TableStyle:
		stage.UnstageBranchTableStyle(target)

	case *Text:
		stage.UnstageBranchText(target)

	default:
		_ = target
	}
}

// insertion point for unstage branch per struct
func (stage *StageStruct) UnstageBranchDocument(document *Document) {

	// check if instance is already staged
	if ! IsStaged(stage, document) {
		return
	}

	document.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if document.File != nil {
		UnstageBranch(stage, document.File)
	}
	if document.Root != nil {
		UnstageBranch(stage, document.Root)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchDocx(docx *Docx) {

	// check if instance is already staged
	if ! IsStaged(stage, docx) {
		return
	}

	docx.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _file := range docx.Files {
		UnstageBranch(stage, _file)
	}

}

func (stage *StageStruct) UnstageBranchFile(file *File) {

	// check if instance is already staged
	if ! IsStaged(stage, file) {
		return
	}

	file.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchNode(node *Node) {

	// check if instance is already staged
	if ! IsStaged(stage, node) {
		return
	}

	node.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _node := range node.Nodes {
		UnstageBranch(stage, _node)
	}

}

func (stage *StageStruct) UnstageBranchParagraph(paragraph *Paragraph) {

	// check if instance is already staged
	if ! IsStaged(stage, paragraph) {
		return
	}

	paragraph.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraph.Node != nil {
		UnstageBranch(stage, paragraph.Node)
	}
	if paragraph.ParagraphProperties != nil {
		UnstageBranch(stage, paragraph.ParagraphProperties)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _rune := range paragraph.Runes {
		UnstageBranch(stage, _rune)
	}

}

func (stage *StageStruct) UnstageBranchParagraphProperties(paragraphproperties *ParagraphProperties) {

	// check if instance is already staged
	if ! IsStaged(stage, paragraphproperties) {
		return
	}

	paragraphproperties.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraphproperties.ParagraphStyle != nil {
		UnstageBranch(stage, paragraphproperties.ParagraphStyle)
	}
	if paragraphproperties.Node != nil {
		UnstageBranch(stage, paragraphproperties.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchParagraphStyle(paragraphstyle *ParagraphStyle) {

	// check if instance is already staged
	if ! IsStaged(stage, paragraphstyle) {
		return
	}

	paragraphstyle.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraphstyle.Node != nil {
		UnstageBranch(stage, paragraphstyle.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchRune(rune *Rune) {

	// check if instance is already staged
	if ! IsStaged(stage, rune) {
		return
	}

	rune.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if rune.Node != nil {
		UnstageBranch(stage, rune.Node)
	}
	if rune.Text != nil {
		UnstageBranch(stage, rune.Text)
	}
	if rune.RuneProperties != nil {
		UnstageBranch(stage, rune.RuneProperties)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchRuneProperties(runeproperties *RuneProperties) {

	// check if instance is already staged
	if ! IsStaged(stage, runeproperties) {
		return
	}

	runeproperties.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if runeproperties.Node != nil {
		UnstageBranch(stage, runeproperties.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchTable(table *Table) {

	// check if instance is already staged
	if ! IsStaged(stage, table) {
		return
	}

	table.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if table.Node != nil {
		UnstageBranch(stage, table.Node)
	}
	if table.TableProperties != nil {
		UnstageBranch(stage, table.TableProperties)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchTableProperties(tableproperties *TableProperties) {

	// check if instance is already staged
	if ! IsStaged(stage, tableproperties) {
		return
	}

	tableproperties.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if tableproperties.Node != nil {
		UnstageBranch(stage, tableproperties.Node)
	}
	if tableproperties.TableStyle != nil {
		UnstageBranch(stage, tableproperties.TableStyle)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchTableStyle(tablestyle *TableStyle) {

	// check if instance is already staged
	if ! IsStaged(stage, tablestyle) {
		return
	}

	tablestyle.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if tablestyle.Node != nil {
		UnstageBranch(stage, tablestyle.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchText(text *Text) {

	// check if instance is already staged
	if ! IsStaged(stage, text) {
		return
	}

	text.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if text.Node != nil {
		UnstageBranch(stage, text.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

