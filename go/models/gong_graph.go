// generated by ModelGongGraphFileTemplate
package models

func IsStaged[Type Gongstruct](stage *StageStruct, instance *Type) (ok bool) {

	switch target := any(instance).(type) {
	// insertion point for stage
	case *Document:
		ok = stage.IsStagedDocument(target)

	case *Docx:
		ok = stage.IsStagedDocx(target)

	case *File:
		ok = stage.IsStagedFile(target)

	case *Node:
		ok = stage.IsStagedNode(target)

	case *Paragraph:
		ok = stage.IsStagedParagraph(target)

	case *ParagraphProperties:
		ok = stage.IsStagedParagraphProperties(target)

	case *Rune:
		ok = stage.IsStagedRune(target)

	case *Text:
		ok = stage.IsStagedText(target)

	default:
		_ = target
	}
	return
}

// insertion point for stage per struct
	func (stage *StageStruct) IsStagedDocument(document *Document) (ok bool) {

		_, ok = stage.Documents[document]
	
		return
	}

	func (stage *StageStruct) IsStagedDocx(docx *Docx) (ok bool) {

		_, ok = stage.Docxs[docx]
	
		return
	}

	func (stage *StageStruct) IsStagedFile(file *File) (ok bool) {

		_, ok = stage.Files[file]
	
		return
	}

	func (stage *StageStruct) IsStagedNode(node *Node) (ok bool) {

		_, ok = stage.Nodes[node]
	
		return
	}

	func (stage *StageStruct) IsStagedParagraph(paragraph *Paragraph) (ok bool) {

		_, ok = stage.Paragraphs[paragraph]
	
		return
	}

	func (stage *StageStruct) IsStagedParagraphProperties(paragraphproperties *ParagraphProperties) (ok bool) {

		_, ok = stage.ParagraphPropertiess[paragraphproperties]
	
		return
	}

	func (stage *StageStruct) IsStagedRune(rune *Rune) (ok bool) {

		_, ok = stage.Runes[rune]
	
		return
	}

	func (stage *StageStruct) IsStagedText(text *Text) (ok bool) {

		_, ok = stage.Texts[text]
	
		return
	}


// StageBranch stages instance and apply StageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func StageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for stage branch
	case *Document:
		stage.StageBranchDocument(target)

	case *Docx:
		stage.StageBranchDocx(target)

	case *File:
		stage.StageBranchFile(target)

	case *Node:
		stage.StageBranchNode(target)

	case *Paragraph:
		stage.StageBranchParagraph(target)

	case *ParagraphProperties:
		stage.StageBranchParagraphProperties(target)

	case *Rune:
		stage.StageBranchRune(target)

	case *Text:
		stage.StageBranchText(target)

	default:
		_ = target
	}
}

// insertion point for stage branch per struct
func (stage *StageStruct) StageBranchDocument(document *Document) {

	// check if instance is already staged
	if IsStaged(stage, document) {
		return
	}

	document.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if document.File != nil {
		StageBranch(stage, document.File)
	}
	if document.Root != nil {
		StageBranch(stage, document.Root)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchDocx(docx *Docx) {

	// check if instance is already staged
	if IsStaged(stage, docx) {
		return
	}

	docx.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _file := range docx.Files {
		StageBranch(stage, _file)
	}

}

func (stage *StageStruct) StageBranchFile(file *File) {

	// check if instance is already staged
	if IsStaged(stage, file) {
		return
	}

	file.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchNode(node *Node) {

	// check if instance is already staged
	if IsStaged(stage, node) {
		return
	}

	node.Stage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _node := range node.Nodes {
		StageBranch(stage, _node)
	}

}

func (stage *StageStruct) StageBranchParagraph(paragraph *Paragraph) {

	// check if instance is already staged
	if IsStaged(stage, paragraph) {
		return
	}

	paragraph.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraph.Node != nil {
		StageBranch(stage, paragraph.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchParagraphProperties(paragraphproperties *ParagraphProperties) {

	// check if instance is already staged
	if IsStaged(stage, paragraphproperties) {
		return
	}

	paragraphproperties.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraphproperties.Node != nil {
		StageBranch(stage, paragraphproperties.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchRune(rune *Rune) {

	// check if instance is already staged
	if IsStaged(stage, rune) {
		return
	}

	rune.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if rune.Node != nil {
		StageBranch(stage, rune.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchText(text *Text) {

	// check if instance is already staged
	if IsStaged(stage, text) {
		return
	}

	text.Stage(stage)

	//insertion point for the staging of instances referenced by pointers
	if text.Node != nil {
		StageBranch(stage, text.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}


// UnstageBranch stages instance and apply UnstageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func UnstageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for unstage branch
	case *Document:
		stage.UnstageBranchDocument(target)

	case *Docx:
		stage.UnstageBranchDocx(target)

	case *File:
		stage.UnstageBranchFile(target)

	case *Node:
		stage.UnstageBranchNode(target)

	case *Paragraph:
		stage.UnstageBranchParagraph(target)

	case *ParagraphProperties:
		stage.UnstageBranchParagraphProperties(target)

	case *Rune:
		stage.UnstageBranchRune(target)

	case *Text:
		stage.UnstageBranchText(target)

	default:
		_ = target
	}
}

// insertion point for unstage branch per struct
func (stage *StageStruct) UnstageBranchDocument(document *Document) {

	// check if instance is already staged
	if ! IsStaged(stage, document) {
		return
	}

	document.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if document.File != nil {
		UnstageBranch(stage, document.File)
	}
	if document.Root != nil {
		UnstageBranch(stage, document.Root)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchDocx(docx *Docx) {

	// check if instance is already staged
	if ! IsStaged(stage, docx) {
		return
	}

	docx.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _file := range docx.Files {
		UnstageBranch(stage, _file)
	}

}

func (stage *StageStruct) UnstageBranchFile(file *File) {

	// check if instance is already staged
	if ! IsStaged(stage, file) {
		return
	}

	file.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchNode(node *Node) {

	// check if instance is already staged
	if ! IsStaged(stage, node) {
		return
	}

	node.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _node := range node.Nodes {
		UnstageBranch(stage, _node)
	}

}

func (stage *StageStruct) UnstageBranchParagraph(paragraph *Paragraph) {

	// check if instance is already staged
	if ! IsStaged(stage, paragraph) {
		return
	}

	paragraph.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraph.Node != nil {
		UnstageBranch(stage, paragraph.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchParagraphProperties(paragraphproperties *ParagraphProperties) {

	// check if instance is already staged
	if ! IsStaged(stage, paragraphproperties) {
		return
	}

	paragraphproperties.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if paragraphproperties.Node != nil {
		UnstageBranch(stage, paragraphproperties.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchRune(rune *Rune) {

	// check if instance is already staged
	if ! IsStaged(stage, rune) {
		return
	}

	rune.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if rune.Node != nil {
		UnstageBranch(stage, rune.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchText(text *Text) {

	// check if instance is already staged
	if ! IsStaged(stage, text) {
		return
	}

	text.Unstage(stage)

	//insertion point for the staging of instances referenced by pointers
	if text.Node != nil {
		UnstageBranch(stage, text.Node)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

